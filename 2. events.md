# Events

## Introduction
Events are important parts of an application. 
They notify us when certain conditions are met so that we can respond appropriately too them.

On the DOM we have event management on elements were you can add event listeners.  
This is a bit harder to accomplish with normal objects.

There are two types of events crs-binding supports:

1. Let me know when a property has changed.
1. Let me know when a condition has been met.

## Observed objects
To listen to events on an object, the object must be observed.  
Observed objects are complex in the sense that they are reactive to object changes.
You may not always want all that overhead but just be interested in property changes.

Classes can be made event enabled but not observed by using :

1. crsbinding.events.enableEvents(this);
1. crsbinding.events.disableEvents(this);

Here is a example of a simple class that is event enabled but not observed.

```js
class Person {
    get firstName() {
        return this._firstName;
    }

    set firstName(newValue) {
        this._firstName = newValue;
        crsbinding.events.notifyPropertyChanged(this, "firstName");
    }

    get lastName() {
        return this._lastName;
    }

    set lastName(newValue) {
        this._lastName = newValue;
        crsbinding.events.notifyPropertyChanged(this, "lastName");
    }

    constructor() {
        crsbinding.events.enableEvents(this);
    }

    dispose() {
        crsbinding.events.disableEvents(this);
    }
}
```

There are a couple of things to note here:

1. The constructor enables the events on the instance using `crsbinding.events.enableEvents`
1. The dispose function cleans up the memory, disabling events on the object using `crsbinding.events.disableEvents`
1. Both property setters use `notifyPropertyChanged` to inform the engine that changes has occurred on the given property. If this is not called, the events will not fire. You can however also call them when ever to want to force a event to fire. This is often used for things like calculated properties where a property change can trigger a event for the calculated property.

To observe an object you use `crsbinding.observation.observe`  

```js
const obj = crsbinding.observation.observe({
    firstName: "name",
    lastName: "lastName"
});
```

Observed objects will manage the `notifyPropertyChanged` on your behalf.
Observed classes are just event enabled classes with more features.

When I have a event enabled class and I just want to execute some code when a given property changes I can do one of two things.

1. Put that code in the setter.
1. If I don't have a getter and setter I can create a function using the following naming convention: `[property]Changed`. For example: `firstNameChanged` or `lastNameChanged`

```js
const obj = crsbinding.observation.observe({
    firstName: "John",
    lastName: "Doe",
    firstNameChagned: () => console.log(this.firstName),
    lastNameChanged: () => console.log(this.lastName)
})
```

When you are done with a observed object, remember to release it using `crsbinding.observation.releaseObserved(obj);`

If you have a number of properties and you don't want to create a changed function for each one you can add one function called "propertyChanged" on the object.

```js
class Person {
    ....

    propertyChanged(property, newValue, oldValue) {
        ....
    }
}
```

## Property change notifications
Lets say that in a view model I want to know when my person model has property changes so that I can manually update the DOM.

`crsbinding.events.on` registers a event on the event driven object.
It has three parameters:

1. The instance to monitor
1. The property name to monitor changes on
1. A function callback to use when the property value changes

```js
const john = new Person();

const updateUI = () => document.querySelector("#name").innerText = john.firstName;

crsbinding.events.on(john, "firstName", updateUI);
```

When you are done and you want to disable the monitor, use `crsbinding.events.removeOn`.
This uses the same three parameters as on because you could have multiple callbacks registered for the same instance and property.

```js
crsbinding.events.removeOn(john, "firstName", updateUI);
```

## Condition met notifications
Events are very similar to property notifications but actually works a little different.  You need to register an event using `crsbinding.events.when`.

This takes three parameters:

1. The instance to monitor
1. The condition to check for
1. The function callback to use when the condition is met.

In the same way, when you are done watching for the event, you use `removeWhen` with the same parameters to clean up.

The big different between `when` and `on` is that `on` notifies you every time the property changes, `when` will only fire the callback once the condition is satisfied.

Lets use this as a example:

```js
const condition = "firstName == 'John' && lastName == 'Doe'";
const showMessage = () => alert("We found him!");

crsbinding.events.when(obj, condition, showMessage);
```

We set the first name: `obj.firstName = "John";` but nothing happens, but when we set the last name: `obj.lastName = "Doe";`. the callback is fired and the message is shown.

Under the hood it listens to each property change and when that the property changes it checks the condition. If the condition fails nothing happens, but when it does pass, the callback is fired.